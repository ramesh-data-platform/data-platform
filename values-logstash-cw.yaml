image:
  repository: garjunan/logstash-oss
  tag: 7.6.2
  pullPolicy: Always

persistence:
  enabled: true
  size: 2Gi

config:
  dead_letter_queue.enable: true

podDisruptionBudget:
  maxUnavailable: 0

livenessProbe:
  initialDelaySeconds: 90


extraEnv: 
- name: ELASTIC_USERNAME
  value: elastic  
- name: ELASTIC_PASSWORD
  valueFrom:
    secretKeyRef:
      key: elastic
      name: poc-elasticsearch-es-elastic-user

volumeMounts:
- name: cacert
  mountPath: /etc/es-cacert/
- name: data
  mountPath: /usr/share/logstash/data
- name: patterns
  mountPath: /usr/share/logstash/patterns
- name: files
  mountPath: /usr/share/logstash/files
- name: pipeline
  mountPath: /usr/share/logstash/pipeline

volumes: 
- name: cacert
  secret:
    secretName: poc-elasticsearch-es-http-certs-public

inputs:
  main: |-
    input {
      kinesis {
        kinesis_stream_name => "lamm-dev-k8s-cw-poc-stream"
        codec => cloudwatch_logs
        region => "us-west-2"
        application_name => "lamm-dev-siem-elk-cwl"
      }
    }
   


filters:
  main: |-
    filter {
      if [logStream] =~ /kube-apiserver-audit-.*/ {
        mutate {
          add_field => { "[@metadata][index_prefix]" => "k8-kube-apiserver-audit" }
        }
      }

      if [logStream] =~ /kube-apiserver-(?!audit).*/ {
        mutate {
          add_field => { "[@metadata][index_prefix]" => "k8-kubeapiserver" }
        }
        grok {
          match => {"message" => "%{DATA:response}%{TIME:timestamp}%{SPACE}%{NUMBER:version}%{SPACE}%{JAVACLASS:class}:%{NUMBER:bytes}%{GREEDYDATA:message}"}
        }
      }

      if [logStream] =~ /kube-controller-manager-.*/ {
        mutate {
          add_field => { "[@metadata][index_prefix]" => "k8-kube-controller-manager" }
        }
        grok {
          match => {"message" => "%{DATA:response}%{TIME:timestamp}%{SPACE}%{NUMBER:version}%{SPACE}%{JAVACLASS:class}:%{NUMBER:bytes}%{GREEDYDATA:message}"}
        }
      }

      if [logStream] =~ /kube-scheduler-.*/ {
        mutate {
          add_field => { "[@metadata][index_prefix]" => "k8-kube-scheduler" }
        }
        grok {
          match => {"message" => "%{DATA:response}%{TIME:timestamp}%{SPACE}%{NUMBER:version}%{SPACE}%{JAVACLASS:class}:%{NUMBER:bytes}%{GREEDYDATA:message}"}
        }
      }
     
      if [logStream] =~ /authenticator-.*/ {
        mutate {
          add_field => { "[@metadata][index_prefix]" => "k8-authenticator" }
        }
        grok {
          match => { "message" => "time=\"%{TIMESTAMP_ISO8601:timestamp}\" level=%{LOGLEVEL:loglevel} msg=\"%{DATA:msg}\" arn=\"%{DATA:arn}\" client=\"%{IP:client}:%{POSINT:clientport}\" groups=\"\[%{DATA:groups}\]\" method=%{WORD:verb} path=%{NOTSPACE:request} uid=\"%{DATA:uid}\" username=\"?%{USERNAME:username}\"?" }
          #match => { "message" => "time=\"%{TIMESTAMP_ISO8601:timestamp}\" level=%{LOGLEVEL:loglevel} msg=\"%{DATA:message}\" arn=\"%{DATA:arn}\" client=\"%{IP:client}:%{POSINT:clientport}\" groups=\"\[%{DATA:groups}\]\" method=%{WORD:method} path=%{NOTSPACE:request} uid=\"%{DATA:userid}\ username=\"%{DATA:username}\" }
        }
      }

    }



outputs:
  main: |-
    output {
      stdout { codec => rubydebug { metadata => true } }
      elasticsearch {
         hosts => "poc-elasticsearch-es-http:9200"
         ssl => true
         ssl_certificate_verification => false
         cacert => "/etc/es-cacert/ca.crt"
         user => "${ELASTIC_USERNAME}"
         password => "${ELASTIC_PASSWORD}"
         manage_template => false
         #index => "poc-elk-kinesis-cloudwatch-%{+YYYY.MM.dd}"
         index => "poc-elk-kinesis-cw-%{[@metadata][index_prefix]}-%{+YYYY.MM.dd}"
      }
    }

